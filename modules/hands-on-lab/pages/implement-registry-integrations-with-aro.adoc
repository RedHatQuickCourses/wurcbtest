#  Implement registry integrations with ARO

= Registry Integrations with Azure Red Hat OpenShift

This module delves into the critical aspect of managing and integrating various container registries with your Azure Red Hat OpenShift (ARO) cluster. Effective registry integration is fundamental for accessing official base images, deploying custom containerized applications, and streamlining internal image build processes.

== Understanding Container Registries in ARO

Container registries serve as central repositories for storing, managing, and distributing container images. In an ARO environment, you will commonly interact with several types of registries, each serving specific purposes:

*   **Internal OpenShift Registry:** A built-in, fully integrated registry within your ARO cluster. It's the default location for images built by OpenShift's S2I (Source-to-Image) or Dockerfile builds and is optimized for in-cluster access.
*   **Azure Container Registry (ACR):** A managed, private Docker container registry service in Azure. It offers deep integration with Azure services and is an excellent choice for hosting private images for applications deployed on ARO within the Azure ecosystem.
*   **Quay.io:** A popular external container registry known for its advanced security features, detailed audit logs, and enterprise-grade capabilities. It's often chosen for robust image management across different environments.
*   **Red Hat Container Registry (registry.redhat.io):** Essential for accessing Red Hat certified container images, base images, and various OpenShift components. Accessing this registry often requires specific authentication.

Each registry offers distinct advantages, and understanding how to integrate them is key to a flexible and secure ARO deployment.

== Using the Internal OpenShift Registry

Every ARO cluster comes equipped with an integrated container image registry, also known as the OpenShift Image Registry. This registry is where images built within your cluster are stored by default, making it highly efficient for internal CI/CD pipelines.

=== Technical Explanation: Internal Access

The internal OpenShift registry is primarily optimized for image storage and retrieval *from within* the cluster. Any pod running in your ARO cluster can seamlessly access this registry using its internal ClusterIP service.

The fully qualified domain name (FQDN) for the internal registry within the cluster is `image-registry.openshift-image-registry.svc.cluster.local:5000`. This design allows for straightforward integration with internal build processes and application deployments, as pods within the cluster do not require additional network configuration or authentication to pull images from it.

=== Technical Explanation: External Access

While the internal registry is excellent for in-cluster operations, scenarios often arise where you need to access it from outside the ARO cluster. This could be from a developer's local workstation, an external CI/CD platform, or even another Kubernetes cluster. To facilitate this external access, you must expose the internal registry through an OpenShift `Route`.

Exposing the registry via a `Route` makes it accessible over the internet (or through a private network if configured appropriately) using an externally routable FQDN. This allows external clients to push and pull images using standard `docker` commands after successful authentication.

=== Hands-on Activity: Exploring and Exposing the Internal Registry

In this activity, you will verify the existence and configuration of the internal OpenShift registry and then expose it for external access using an OpenShift Route.

.Prerequisites
*   You are logged into your ARO cluster as a `kubeadmin` user or a user with `cluster-admin` privileges.
*   You have the `oc` (OpenShift CLI) and `docker` CLIs installed and configured.

.Steps

. *Verify Internal Registry Service*:
.. First, confirm that the internal image registry service is running within your cluster.
+
```bash
oc get service -n openshift-image-registry image-registry
```
+
You should observe output similar to the following, confirming the existence of the ClusterIP service:
+
```console
NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
image-registry   ClusterIP   172.30.170.218   <none>        5000/TCP   7d
```

. *Expose the Internal Registry Externally*:
.. To enable external access, you will configure the image registry operator to create a default `Route` for the `image-registry` service.
+
```bash
oc patch configs.imageregistry.operator.openshift.io/cluster --patch '{"spec":{"defaultRoute":true}}' --type=merge
```
+
This command instructs the image registry operator to automatically provision a standard HTTP/S route for the registry.

. *Find the External Registry FQDN*:
.. Allow a few moments for the Route to be provisioned. You can then retrieve its externally routable FQDN using the following command:
+
```bash
oc get route default-route -n openshift-image-registry --template='{{ .spec.host }}'
```
+
This command will output the full hostname (e.g., `default-route-openshift-image-registry.apps.your-cluster-domain.com`) that external clients will use to interact with the registry.

. *Authenticate for External Access*:
.. To push or pull images from the newly exposed external registry, you must authenticate. For users with a valid OpenShift token (like `kubeadmin`), you can perform a `docker login` using the obtained FQDN and your OpenShift token.
+
```bash
TOKEN=$(oc whoami --show-token)
REGISTRY_HOST=$(oc get route default-route -n openshift-image-registry --template='{{ .spec.host }}')
echo $TOKEN | docker login -u kubeadmin --password-stdin $REGISTRY_HOST
```
+
[NOTE]
====
If you are not using the `kubeadmin` account, replace `kubeadmin` with your actual OpenShift username.
====
+
Upon successful login, you can now use standard `docker push` and `docker pull` commands, referencing the `REGISTRY_HOST` for your image operations.

== Integrating with Red Hat Container Registry (registry.redhat.io)

Accessing images from `registry.redhat.io` is often critical for leveraging Red Hat's certified container content, essential OpenShift components, and official base images. To pull private or certified images from this registry, you typically need a service account from Red Hat's Registry Service Account Management application.

=== Technical Explanation

The Red Hat Container Registry requires authentication for most of its valuable content. For programmatic access by an ARO cluster, using a dedicated *service account* is the recommended best practice, rather than your personal Red Hat account credentials. A service account provides a specific username and password suitable for automated systems to pull images.

Once you obtain the service account credentials, they are typically stored within OpenShift as a Kubernetes `Secret` of type `kubernetes.io/dockerconfigjson`. This secret can then be linked to an OpenShift `ServiceAccount` or directly specified in your pod/deployment definitions using `imagePullSecrets`. For cluster-wide pull access, you might update the global pull secret configuration.

=== Hands-on Activity: Creating a Red Hat Container Registry Service Account

This activity guides you through the process of creating a service account for `registry.redhat.io`. This service account will provide the credentials necessary for your ARO cluster to pull images from Red Hat's registry.

.Prerequisites
*   An active Red Hat account.

.Steps

. *Sign in to Registry Service Account Management*:
.. Use your Red Hat account to sign in to the link:https://access.redhat.com/management/systems/service-accounts[Registry Service Account Management Application^].

. *Create a New Service Account*:
.. On the *Registry Service Accounts* page, locate and select *New Service Account*.

. *Provide Account Details*:
.. Enter a descriptive name for your Service Account (e.g., `aro-registry-puller`). Note that Red Hat will prepend a fixed, random string to this name.
.. Add a brief description for clarity.
.. Select *Create*.

. *Retrieve Credentials*:
.. Navigate back to your list of *Service Accounts*.
.. Select the Service Account you just created.
.. *Carefully note down the username*: This will include the prepended random string (e.g., `XXXXXXX|aro-registry-puller`). This is the full username to use when authenticating with `registry.redhat.io`.
.. *Carefully note down the password*: This is the system-generated password for the service account. Use this password when authenticating.

. *Prepare `config.json` (Conceptual)*:
.. While you've noted the credentials, typically, a `docker login` command would generate a `~/.docker/config.json` entry. For illustration:
+
```bash
docker login registry.redhat.io -u "XXXXXXX|aro-registry-puller" -p "YOUR_SERVICE_ACCOUNT_PASSWORD"
```
+
This command would add an entry to your `config.json` resembling the format shown in the context:
+
```json
{
  "auths": {
    "registry.redhat.io": {
      "auth": "xxxx...xxx", // Base64 encoded "username:password"
      "email": "your-email@example.com"
    }
    // ... potentially other registry entries
  }
}
```
+
The `auth` field contains the Base64-encoded `username:password` string.

. *Integrate with ARO (Conceptual)*:
.. With these credentials, you can create a `kubernetes.io/dockerconfigjson` secret in OpenShift. For example, in a specific project:
+
```bash
oc create secret docker-registry redhat-pull-secret \
  --docker-server=registry.redhat.io \
  --docker-username="XXXXXXX|aro-registry-puller" \
  --docker-password="YOUR_SERVICE_ACCOUNT_PASSWORD" \
  --docker-email="your-email@example.com" \
  -n your-project
```
+
After creation, you would link this secret to your `ServiceAccount` or specify it in your Deployment/Pod manifests. For cluster-wide pull access for all projects, you can merge this secret into the cluster's global `image.config` resource.

== Integrating with Azure Container Registry (ACR)

Azure Container Registry (ACR) is a fully managed, private Docker registry service provided by Azure. It's an excellent choice for storing private images for your ARO applications due to its deep integration with Azure services and robust enterprise-grade features like geo-replication and content trust.

=== Technical Explanation

Integrating ARO with ACR primarily involves creating an `ImagePullSecret` in OpenShift that holds the necessary credentials to access your ACR instance. Several methods exist for authenticating with ACR:

1.  **Admin User Account:** You can enable an admin user for your ACR and use its static username and password. While straightforward, this method is generally *not recommended* for production environments due to security considerations.
2.  **Azure Active Directory Service Principal:** This is the recommended and most secure approach. You create an Azure Active Directory service principal, grant it `AcrPull` (or `AcrPush`) permissions to your ACR, and then use its `appId` (client ID) and `password` (client secret) as credentials.
3.  **Managed Identities:** For advanced scenarios, if your ARO worker nodes utilize Managed Identities, you can grant the node's identity permissions to pull from ACR. This eliminates the need for explicit secrets in OpenShift, enhancing security.

For typical integration, we'll focus on the `Service Principal` approach, which maps directly to a `kubernetes.io/dockerconfigjson` secret.

=== Hands-on Activity: Configuring ARO to Pull Images from ACR

This activity outlines the steps to configure your ARO cluster to pull images from an Azure Container Registry (ACR) using an Azure Active Directory service principal.

.Prerequisites
*   An existing Azure Container Registry (ACR) instance.
*   The `az` (Azure CLI) and `oc` (OpenShift CLI) tools installed and configured.

.Steps

. *Log in to Azure CLI*:
.. Ensure you are logged into Azure CLI with an account that has permissions to manage ACR and create service principals (if you need to create a new one).
+
```bash
az login
```

. *Create a Service Principal for ACR (if you don't have one)*:
.. If you don't already have a service principal with access to your ACR, create one. Replace `<ACR_NAME>` with the name of your ACR and `<RESOURCE_GROUP>` with the name of its resource group.
+
```bash
ACR_ID=$(az acr show --name <ACR_NAME> --query id --output tsv)
az ad sp create-for-rbac --name http://<YOUR_SP_NAME> --scopes $ACR_ID --role AcrPull --query "{ appID: appId, password: password }"
```
+
*Carefully note down the `appID` (client ID) and `password` (client secret) from the output.* These will be your username and password for the secret.

. *Create a `dockerconfigjson` Secret in OpenShift*:
.. Use the service principal credentials to create a `kubernetes.io/dockerconfigjson` secret in your target OpenShift project. Replace `<ACR_LOGIN_SERVER>` (e.g., `myacr.azurecr.io`), `<SP_APP_ID>`, `<SP_PASSWORD>`, and `your-email@example.com` with your specific details.
+
```bash
oc create secret docker-registry acr-pull-secret \
  --docker-server=<ACR_LOGIN_SERVER> \
  --docker-username=<SP_APP_ID> \
  --docker-password=<SP_PASSWORD> \
  --docker-email=your-email@example.com \
  -n your-project
```
+
[TIP]
====
You can find your ACR login server in the Azure portal under your ACR instance's "Overview" blade (e.g., `myregistry.azurecr.io` or `myregistry.azurecr.io:8080` for private link setup).
====

. *Link the Secret to a ServiceAccount (or Deployment)*:
.. To allow pods in your `your-project` to automatically pull images from ACR, link this secret to the `default` ServiceAccount or a custom one you are using.
+
```bash
oc secrets link default acr-pull-secret --for=pull -n your-project
```
+
Alternatively, you can specify `imagePullSecrets` directly within your Deployment or Pod manifest:
+
```yaml
# ... (in a Deployment or Pod spec)
spec:
  containers:
  - name: my-app
    image: <ACR_LOGIN_SERVER>/myrepo/myimage:latest
    # ...
  imagePullSecrets:
  - name: acr-pull-secret
```

. *Verify Image Pull*:
.. Deploy a sample application that utilizes an image hosted in your ACR. OpenShift should now be able to pull the image successfully, demonstrating the successful integration.

== Integrating with Quay

Quay.io is an open-source and enterprise container registry solution, widely recognized for its robust security features, detailed audit logs, and integrated build automation. Integrating your ARO cluster with Quay enables you to leverage images stored in private Quay repositories, maintaining a consistent and secure supply chain.

=== Technical Explanation

Similar to integrating with ACR or other private registries, the process of integrating ARO with Quay involves creating an `ImagePullSecret` that contains the necessary authentication token or credentials for your Quay repository. Quay supports several authentication methods suitable for different use cases:

1.  **Robot Accounts:** These are programmatic accounts with granular permissions, ideal for CI/CD systems, automated deployments, and OpenShift integrations. You generate a unique token for each robot account.
2.  **User Credentials:** While possible, using your personal Quay username and password for automated systems is generally less recommended due to security and manageability concerns.

The chosen credentials (typically a robot account username and token) are encoded into a `kubernetes.io/dockerconfigjson` secret. OpenShift then uses this secret to authenticate with Quay when attempting to pull images.

=== Hands-on Activity: Configuring ARO to Pull Images from Quay

This activity guides you through the process of creating an OpenShift secret to enable your ARO cluster to pull images from a private Quay.io repository using a dedicated Robot Account.

.Prerequisites
*   A Quay.io account and a private repository.
*   The `oc` (OpenShift CLI) tool installed and configured.

.Steps

. *Create a Quay.io Robot Account and Token (if you don't have one)*:
.. In your Quay.io account, navigate to the specific private repository you wish to access.
.. Go to *Settings* -> *Robot Accounts*.
.. Create a new Robot Account. Assign it a descriptive name (e.g., `aro-quay-puller`) and ensure it has at least *Read* (pull) permissions for the target repository.
.. *Generate a token* for the robot account. *Copy this token immediately*, as it will typically not be displayed again after creation.
+
[NOTE]
====
Your Robot Account username will usually be in the format `namespace+robot_account_name` (e.g., `myorganization+aro-quay-puller`).
====

. *Create a `dockerconfigjson` Secret in OpenShift*:
.. Use the Robot Account credentials (username and token) to create a `kubernetes.io/dockerconfigjson` secret in your target OpenShift project. Replace `<QUAY_ROBOT_ACCOUNT_USERNAME>`, `<QUAY_ROBOT_ACCOUNT_TOKEN>`, and `your-email@example.com` with your specific details.
+
```bash
oc create secret docker-registry quay-pull-secret \
  --docker-server=quay.io \
  --docker-username=<QUAY_ROBOT_ACCOUNT_USERNAME> \
  --docker-password=<QUAY_ROBOT_ACCOUNT_TOKEN> \
  --docker-email=your-email@example.com \
  -n your-project
```

. *Link the Secret to a ServiceAccount (or Deployment)*:
.. Similar to ACR integration, link this newly created secret to the `default` ServiceAccount or a custom one in your `your-project` to automatically apply it to pods.
+
```bash
oc secrets link default quay-pull-secret --for=pull -n your-project
```
+
Alternatively, you can explicitly specify `imagePullSecrets` directly within your Deployment or Pod manifest:
+
```yaml
# ... (in a Deployment or Pod spec)
spec:
  containers:
  - name: my-app
    image: quay.io/my-org/my-private-image:latest
    # ...
  imagePullSecrets:
  - name: quay-pull-secret
```

. *Verify Image Pull*:
.. Deploy a test application that uses an image from your private Quay.io repository. Observe that OpenShift successfully pulls the image, confirming the integration is working as expected.